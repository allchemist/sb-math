(in-package :sb-math)

(defun lu (A)
  (let ((dim (dim0 A))
	(element-type (array-element-type A)))
    (assert (= dim (dim1 A)) nil "Matrix should be sqhare")
    (let ((copy-A (copy A))
	  (ipiv (make-matrix dim :element-type '(unsigned-byte 32))))
      (sb-sys:with-pinned-objects (copy-A ipiv)
	(funcall (with-function-choice 'getrf element-type t) copy-A ipiv))
      (values copy-A ipiv))))

(defun lu-inverse (A)
  (let* ((dim (dim0 A))
	 (element-type (array-element-type A))
	 (complex? (subtypep element-type 'complex)))
    (assert (= dim (dim1 A)) nil "Matrix should be sqhare")
    (multiple-value-bind (LU P)
	(lu A)
      (let ((work (make-matrix (* dim 2)
			       :element-type (if complex?
						 (second element-type)
						 element-type))))
	(sb-sys:with-pinned-objects (LU P work)
	  (funcall (with-function-choice 'getri element-type t) LU P work))
	LU))))

(defun lu-solve (A B &key (trans :notrans))
  (let* ((dim (dim0 A))
	 (X (if (vectorp B) (copy B) (transpose B)))
	 (real-A A)
	 (element-type (array-element-type A))
	 (real-trans (ecase trans
		       (:notrans :trans)
		       (:trans :notrans)
		       (:conjtrans (progn (setf real-A (transpose A))
					  :conjtrans)))))
    (assert (= dim (dim1 A) (dim1 X)) nil "MAtrix should be square")
    (multiple-value-bind (LU P)
	(lu real-A)
      (sb-sys:with-pinned-objects (LU X P)
	(funcall (with-function-choice 'getrs element-type t)
		 (lapack-char-code real-trans) LU X P))
      (if (vectorp B) (copy X) (transpose X)))))

(defun svd (A &key vecs)
  (let* ((dim0 (dim0 A)) (dim1 (dim1 A))
	 (job (if vecs :all :none))
	 (element-type (array-element-type A))
	 (complex? (subtypep element-type 'complex))
	 (S (make-matrix (min dim0 dim1)
			 :element-type (if complex? (second element-type) element-type)))
	 (U (make-matrix (list dim0 (if vecs dim0 1))
			 :element-type element-type))
	 (VT (make-matrix (list (if vecs dim1 1) dim1)
			  :element-type element-type))
	 (work (make-matrix (* 2 (max (+ (* 3 (min dim0 dim1)) (max dim0 dim1))
				      (* 5 (min dim0 dim1))))
			    :element-type element-type))
	 (rwork (when complex? (make-matrix (* 10 (min dim0 dim1))
					    :element-type (second element-type))))
	 (copy-A (copy A))
	 (job-code (lapack-char-code job)))
    (let ((info
	   (sb-sys:with-pinned-objects (copy-A S U VT work)
	     (apply (with-float-type-choice element-type
		      #'sgesvd #'dgesvd #'cgesvd #'zgesvd)
		    job-code job-code copy-A S U VT work (if complex? (list rwork) '())))))
      (cond ((zerop info)
	     (if vecs
		 (values S U VT)
		 S))
	    ((minusp info)
	     (error "Illegal ~A'th parameter for %gesvd" (- info)))
	    ((plusp info)
	     (error "~A superdiagonals did not converge" info))))))
